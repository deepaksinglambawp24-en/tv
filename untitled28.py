# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XtToPyhaclTVRDeoQYDMTbMD69ihm76f
"""

import streamlit as st
import joblib
import pandas as pd
import os

# --- Configuration ---
MODEL_PATH = 'trained_model.joblib'
# IMPORTANT: Replace these with the EXACT feature names your model was trained on.
FEATURE_NAMES = [
    'Advertising_Spend',
    'Price_of_Product',
    'Store_Size_sq_ft',
    'Competition_Index'
]
# ---------------------

# --- Model Loading Function ---
@st.cache_resource
def load_model(path):
    """Loads the joblib model file with compatibility fix."""
    if not os.path.exists(path):
        st.error(f"Error: Model file not found at '{path}'. Please ensure '{MODEL_PATH}' is in the same directory.")
        return None

    # --- START OF SCALING/VERSION COMPATIBILITY FIX ---
    # This addresses the 'Can't get attribute '_RemainderColsList'' error
    # by temporarily defining the missing attribute in the scikit-learn module.
    try:
        from sklearn.compose import _column_transformer
        if not hasattr(_column_transformer, '_RemainderColsList'):
            # Define a dummy class to satisfy the pickle loader
            class _RemainderColsList(list):
                pass
            setattr(_column_transformer, '_RemainderColsList', _RemainderColsList)
            st.warning("Applied scikit-learn compatibility fix for '_RemainderColsList'. If issues persist, update scikit-learn.")
    except ImportError:
        # This occurs if sklearn is not installed, but joblib.load will catch that later.
        pass
    # --- END OF COMPATIBILITY FIX ---

    try:
        # joblib.load() is called after the fix is applied
        model = joblib.load(path)
        return model
    except Exception as e:
        st.error(f"Error loading the model: {e}")
        st.caption("If the error is still a missing attribute, consider updating scikit-learn to a version compatible with how the model was trained.")
        return None


# Load the model
model = load_model(MODEL_PATH)

# --- Streamlit App Layout ---
st.set_page_config(page_title="Sales Prediction App", layout="centered")

st.title("üí∞ Sales Prediction Model Deployment")
st.markdown("Use the controls below to input the feature values and predict the total sales.")

if model is not None:
    # --- Input Feature Collection ---
    st.header("Input Features")

    # Dictionary to store user inputs
    input_data = {}

    # Helper to create customized input fields for each feature
    col1, col2 = st.columns(2)

    # Use placeholder values, user should adjust min/max/default based on their data
    with col1:
        input_data['Advertising_Spend'] = st.number_input(
            label="Advertising Spend (e.g., $)",
            min_value=0.0,
            value=500.0,
            step=10.0
        )
        input_data['Store_Size_sq_ft'] = st.number_input(
            label="Store Size (sq ft)",
            min_value=100.0,
            value=2500.0,
            step=100.0
        )

    with col2:
        input_data['Price_of_Product'] = st.number_input(
            label="Product Price ($)",
            min_value=1.0,
            value=19.99,
            step=0.1
        )
        input_data['Competition_Index'] = st.slider(
            label="Competition Index (1=Low, 10=High)",
            min_value=1,
            max_value=10,
            value=5,
            step=1
        )

    # --- Prediction Button and Logic ---
    if st.button("Predict Sales", type="primary"):
        try:
            # 1. Convert inputs to a DataFrame
            # Ensure the DataFrame column names and order match the FEATURE_NAMES list
            input_df = pd.DataFrame([input_data])
            input_df = input_df[FEATURE_NAMES] # Reorder to match model expectations

            # 2. Make the prediction
            prediction = model.predict(input_df)

            # The prediction result might be an array, so we take the first element
            predicted_sales = prediction[0]

            # 3. Display the result
            st.success("---")
            st.metric(
                label="Predicted Sales (Y Variable)",
                value=f"${predicted_sales:,.2f}"
            )
            st.balloons()

        except Exception as e:
            st.error(f"An error occurred during prediction: {e}")
            st.caption("If the error is related to feature shape or naming, check the `FEATURE_NAMES` list at the top of the script.")

else:
    st.warning("Prediction cannot be performed because the model failed to load.")

# --- Customization Note ---
st.sidebar.markdown(
    """
    **üõ†Ô∏è Customization Reminder:**

    1. **Replace `FEATURE_NAMES`**: Update the list at the top of the script with the exact column names your model expects.
    2. **Update Input Fields**: Modify the input fields (`st.number_input`, etc.) to match the number, type, and typical range of your actual features.
    """
)